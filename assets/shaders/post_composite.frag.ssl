@glslversion 430 core
@shadertype fragment
@namespace post_composite.frag

layout(binding = 0) uniform sampler2D texSceneHDR;
layout(binding = 1) uniform sampler2D texEHAAEdgeHeuristic;

in vec2 vScreenTexCoord;

out vec3 outFragProcessed;

vec3 acesFilm(vec3 x) {
	float a = 2.51;
	float b = 0.03;
	float c = 2.43;
	float d = 0.59;
	float e = 0.14;
	return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec3(0.0), vec3(1.0));
}

vec3 tonemapFrag(vec3 fragHDR, float exposure) {
	fragHDR *= exposure;
	vec3 mappedFrag = pow(fragHDR, vec3(1.0/2.2)); // Simple gamma correction
	return mappedFrag;
}

void main() {
	// Sample scene frag
	vec3 sceneFragHDR = texture(texSceneHDR, vScreenTexCoord.st).rgb;
	
	/*
	{// New algorithm
		// PROBLEM #1: We can still sample our own triangle by accident on slight angles
		// PROBLEM #2: How to blend pulled samples together? (Possibly related to the problem #1)
		
		const vec2 invTexSize = 1.0 / vec2(textureSize(texSceneHDR, 0));
		vec4 edgeCoeffs = texture(texEHAAEdgeHeuristic, vScreenTexCoord.st).xyzw;
		
		vec4 adjacentCoverageFactors = normalize(edgeCoeffs.xyzw);
		
		float maxCoeff = max(max(edgeCoeffs[0], edgeCoeffs[1]), max(edgeCoeffs[2], edgeCoeffs[3]));
		if(maxCoeff > 0.0001) {
			vec3 pulledFrag = vec3(0.0);
			pulledFrag += tonemapFrag(texture(texSceneHDR, vScreenTexCoord + vec2(invTexSize.x, 0.0)).rgb, 1.0) * adjacentCoverageFactors[0];
			pulledFrag += tonemapFrag(texture(texSceneHDR, vScreenTexCoord + vec2(0.0, invTexSize.y)).rgb, 1.0) * adjacentCoverageFactors[1];
			pulledFrag += tonemapFrag(texture(texSceneHDR, vScreenTexCoord - vec2(invTexSize.x, 0.0)).rgb, 1.0) * adjacentCoverageFactors[2];
			pulledFrag += tonemapFrag(texture(texSceneHDR, vScreenTexCoord - vec2(0.0, invTexSize.y)).rgb, 1.0) * adjacentCoverageFactors[3];
			pulledFrag *= 1.0 / dot(adjacentCoverageFactors, vec4(1.0));
			
			sceneFragHDR = mix(tonemapFrag(sceneFragHDR, 1.0), pulledFrag, maxCoeff);
		}
	}
	*/
	
	/*
	{// DEBUG:
		vec2 invTexSize = 1.0 / vec2(textureSize(texSceneHDR, 0));
		
		vec4 ehaaFrag = texture(texEHAAEdgeHeuristic, vScreenTexCoord.st).xyzw;
		vec2 normal = normalize(ehaaFrag.yz * 2.0 - 1.0);
		
		vec2 sampleNormal = sign(normal) * step(vec2(0.5), abs(normal));
		
		vec2 sampleOffset = invTexSize * sampleNormal;
		vec3 pulledFrag = texture(texSceneHDR, vScreenTexCoord + sampleOffset).rgb;
		
		sceneFragHDR = mix(tonemapFrag(sceneFragHDR), tonemapFrag(pulledFrag), ehaaFrag.x);
		//sceneFragHDR = vec3(sampleNormal * 0.5 + 0.5, 0.0);
	}
	*/
	
	// Tone map and gamma correct fragment
	float exposure = 1.0;
	vec3 tonemappedFrag = tonemapFrag(sceneFragHDR, exposure);
	
	// Write final processed frag
	outFragProcessed = tonemappedFrag;
}
