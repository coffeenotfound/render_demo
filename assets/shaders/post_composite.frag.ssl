@glslversion 430 core
@shadertype fragment
@namespace post_composite.frag

#extension GL_NV_gpu_shader5 : require

layout(binding = 0) uniform sampler2D texSceneHDR;
layout(binding = 4) uniform sampler2DMS texSceneDepthMS; // DEBUG: Used for test SDAA impl

layout(binding = 1) uniform usampler2D texEHAAEdgeHeuristic;
layout(binding = 2) uniform sampler2D texEHAAEdgeHeuristic2;

in vec2 vScreenTexCoord;

out vec3 outFragProcessed;

const uint16_t EDGE_TO_COVERGE_MARK_LUT[32*32] = {
	0xFF00us, 0xFF00us, 0xFF00us, 0xFF00us, 0xFF00us, 0xFF00us, 0xFF00us, 0xFF00us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0xFF00us, 0xFF00us, 0xFF00us, 0xFF10us, 0xFF10us, 0xFF10us, 0xFF30us, 0xFF30us, 0xFF30us, 0xFF70us, 0xFF70us, 0xFF70us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF1us, 0xFFF1us, 0xFFF1us, 0xFFF3us, 0xFFF3us, 0xFFF3us, 0xFFF7us, 0xFFF7us, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0xF710us, 0xF710us, 0xFF10us, 0xFF10us, 0xFF30us, 0xFF30us, 0xFF30us, 0xFF30us, 0xFF30us, 0xFF30us, 0xFF70us, 0xFF70us, 0xFF71us, 0xFF71us, 0xFF71us, 0xFFF1us, 0xFFF1us, 0xFFF3us, 0xFFF3us, 0xFFF3us, 0xFFF3us, 0xFFF3us, 0xFFF3us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0xF710us, 0xF710us, 0xF730us, 0xF730us, 0xF730us, 0xF730us, 0xFF31us, 0xFF31us, 0xFF31us, 0xFF31us, 0xFF71us, 0xFF71us, 0xFF71us, 0xFF71us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFFF3us, 0xFFF3us, 0xFFF3us, 0xFFF3us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFFFus, 0xFFFFus, 
	0x7310us, 0xF731us, 0xF731us, 0xF731us, 0xF731us, 0xF731us, 0xF731us, 0xF731us, 0xF731us, 0xF731us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFFFus, 0xFFFFus, 
	0x7331us, 0x7331us, 0x7731us, 0x7731us, 0x7731us, 0x7731us, 0xF733us, 0xF733us, 0xF733us, 0xF733us, 0xF773us, 0xF773us, 0xF773us, 0xF773us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFF73us, 0xFF77us, 0xFF77us, 0xFF77us, 0xFF77us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFFFus, 0xFFFFus, 
	0x7331us, 0x7331us, 0x7333us, 0x7333us, 0x7733us, 0x7733us, 0x7733us, 0x7733us, 0x7733us, 0x7733us, 0x7773us, 0x7773us, 0xF773us, 0xF773us, 0xF773us, 0xF777us, 0xF777us, 0xFF77us, 0xFF77us, 0xFF77us, 0xFF77us, 0xFF77us, 0xFF77us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFF7us, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0x3333us, 0x3333us, 0x3333us, 0x7333us, 0x7333us, 0x7333us, 0x7733us, 0x7733us, 0x7733us, 0x7773us, 0x7773us, 0x7773us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0xF777us, 0xF777us, 0xF777us, 0xFF77us, 0xFF77us, 0xFF77us, 0xFFF7us, 0xFFF7us, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0x3333us, 0x3333us, 0x3333us, 0x3333us, 0x3333us, 0x3333us, 0x3333us, 0x3333us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0x3333us, 0x3333us, 0x3333us, 0x3337us, 0x3337us, 0x3337us, 0x3377us, 0x3377us, 0x3377us, 0x3777us, 0x3777us, 0x3777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x7777us, 0x777Fus, 0x777Fus, 0x777Fus, 0x77FFus, 0x77FFus, 0x77FFus, 0x7FFFus, 0x7FFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0x1337us, 0x1337us, 0x3337us, 0x3337us, 0x3377us, 0x3377us, 0x3377us, 0x3377us, 0x3377us, 0x3377us, 0x3777us, 0x3777us, 0x377Fus, 0x377Fus, 0x377Fus, 0x777Fus, 0x777Fus, 0x77FFus, 0x77FFus, 0x77FFus, 0x77FFus, 0x77FFus, 0x77FFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0x1337us, 0x1337us, 0x1377us, 0x1377us, 0x1377us, 0x1377us, 0x337Fus, 0x337Fus, 0x337Fus, 0x337Fus, 0x377Fus, 0x377Fus, 0x377Fus, 0x377Fus, 0x37FFus, 0x37FFus, 0x37FFus, 0x37FFus, 0x77FFus, 0x77FFus, 0x77FFus, 0x77FFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0xFFFFus, 0xFFFFus, 
	0x0137us, 0x137Fus, 0x137Fus, 0x137Fus, 0x137Fus, 0x137Fus, 0x137Fus, 0x137Fus, 0x137Fus, 0x137Fus, 0x37FFus, 0x37FFus, 0x37FFus, 0x37FFus, 0x37FFus, 0x37FFus, 0x37FFus, 0x37FFus, 0x37FFus, 0x37FFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0xFFFFus, 0xFFFFus, 
	0x017Fus, 0x017Fus, 0x037Fus, 0x037Fus, 0x037Fus, 0x037Fus, 0x13FFus, 0x13FFus, 0x13FFus, 0x13FFus, 0x17FFus, 0x17FFus, 0x17FFus, 0x17FFus, 0x37FFus, 0x37FFus, 0x37FFus, 0x37FFus, 0x3FFFus, 0x3FFFus, 0x3FFFus, 0x3FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0xFFFFus, 0xFFFFus, 
	0x017Fus, 0x017Fus, 0x01FFus, 0x01FFus, 0x03FFus, 0x03FFus, 0x03FFus, 0x03FFus, 0x03FFus, 0x03FFus, 0x07FFus, 0x07FFus, 0x17FFus, 0x17FFus, 0x17FFus, 0x1FFFus, 0x1FFFus, 0x3FFFus, 0x3FFFus, 0x3FFFus, 0x3FFFus, 0x3FFFus, 0x3FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0x7FFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0x00FFus, 0x00FFus, 0x00FFus, 0x01FFus, 0x01FFus, 0x01FFus, 0x03FFus, 0x03FFus, 0x03FFus, 0x07FFus, 0x07FFus, 0x07FFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x1FFFus, 0x1FFFus, 0x1FFFus, 0x3FFFus, 0x3FFFus, 0x3FFFus, 0x7FFFus, 0x7FFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0x00FFus, 0x00FFus, 0x00FFus, 0x00FFus, 0x00FFus, 0x00FFus, 0x00FFus, 0x00FFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0x00FFus, 0x00FFus, 0x00FFus, 0x08FFus, 0x08FFus, 0x08FFus, 0x0CFFus, 0x0CFFus, 0x0CFFus, 0x0EFFus, 0x0EFFus, 0x0EFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x0FFFus, 0x8FFFus, 0x8FFFus, 0x8FFFus, 0xCFFFus, 0xCFFFus, 0xCFFFus, 0xEFFFus, 0xEFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0x08EFus, 0x08EFus, 0x08FFus, 0x08FFus, 0x0CFFus, 0x0CFFus, 0x0CFFus, 0x0CFFus, 0x0CFFus, 0x0CFFus, 0x0EFFus, 0x0EFFus, 0x8EFFus, 0x8EFFus, 0x8EFFus, 0x8FFFus, 0x8FFFus, 0xCFFFus, 0xCFFFus, 0xCFFFus, 0xCFFFus, 0xCFFFus, 0xCFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0x08EFus, 0x08EFus, 0x0CEFus, 0x0CEFus, 0x0CEFus, 0x0CEFus, 0x8CFFus, 0x8CFFus, 0x8CFFus, 0x8CFFus, 0x8EFFus, 0x8EFFus, 0x8EFFus, 0x8EFFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xCFFFus, 0xCFFFus, 0xCFFFus, 0xCFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xFFFFus, 0xFFFFus, 
	0x08CFus, 0x8CEFus, 0x8CEFus, 0x8CEFus, 0x8CEFus, 0x8CEFus, 0x8CEFus, 0x8CEFus, 0x8CEFus, 0x8CEFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xFFFFus, 0xFFFFus, 
	0x8CCEus, 0x8CCEus, 0x8CEEus, 0x8CEEus, 0x8CEEus, 0x8CEEus, 0xCCEFus, 0xCCEFus, 0xCCEFus, 0xCCEFus, 0xCEEFus, 0xCEEFus, 0xCEEFus, 0xCEEFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xCEFFus, 0xEEFFus, 0xEEFFus, 0xEEFFus, 0xEEFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xFFFFus, 0xFFFFus, 
	0x8CCEus, 0x8CCEus, 0xCCCEus, 0xCCCEus, 0xCCEEus, 0xCCEEus, 0xCCEEus, 0xCCEEus, 0xCCEEus, 0xCCEEus, 0xCEEEus, 0xCEEEus, 0xCEEFus, 0xCEEFus, 0xCEEFus, 0xEEEFus, 0xEEEFus, 0xEEFFus, 0xEEFFus, 0xEEFFus, 0xEEFFus, 0xEEFFus, 0xEEFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xEFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0xCCCCus, 0xCCCCus, 0xCCCCus, 0xCCCEus, 0xCCCEus, 0xCCCEus, 0xCCEEus, 0xCCEEus, 0xCCEEus, 0xCEEEus, 0xCEEEus, 0xCEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEFus, 0xEEEFus, 0xEEEFus, 0xEEFFus, 0xEEFFus, 0xEEFFus, 0xEFFFus, 0xEFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0xCCCCus, 0xCCCCus, 0xCCCCus, 0xCCCCus, 0xCCCCus, 0xCCCCus, 0xCCCCus, 0xCCCCus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0xCCCCus, 0xCCCCus, 0xCCCCus, 0xECCCus, 0xECCCus, 0xECCCus, 0xEECCus, 0xEECCus, 0xEECCus, 0xEEECus, 0xEEECus, 0xEEECus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xEEEEus, 0xFEEEus, 0xFEEEus, 0xFEEEus, 0xFFEEus, 0xFFEEus, 0xFFEEus, 0xFFFEus, 0xFFFEus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0xECC8us, 0xECC8us, 0xECCCus, 0xECCCus, 0xEECCus, 0xEECCus, 0xEECCus, 0xEECCus, 0xEECCus, 0xEECCus, 0xEEECus, 0xEEECus, 0xFEECus, 0xFEECus, 0xFEECus, 0xFEEEus, 0xFEEEus, 0xFFEEus, 0xFFEEus, 0xFFEEus, 0xFFEEus, 0xFFEEus, 0xFFEEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0xECC8us, 0xECC8us, 0xEEC8us, 0xEEC8us, 0xEEC8us, 0xEEC8us, 0xFECCus, 0xFECCus, 0xFECCus, 0xFECCus, 0xFEECus, 0xFEECus, 0xFEECus, 0xFEECus, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFEEus, 0xFFEEus, 0xFFEEus, 0xFFEEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFFus, 0xFFFFus, 
	0xEC88us, 0xFEC8us, 0xFEC8us, 0xFEC8us, 0xFEC8us, 0xFEC8us, 0xFEC8us, 0xFEC8us, 0xFEC8us, 0xFEC8us, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFFus, 0xFFFFus, 
	0xFE80us, 0xFE80us, 0xFEC0us, 0xFEC0us, 0xFEC0us, 0xFEC0us, 0xFFC8us, 0xFFC8us, 0xFFC8us, 0xFFC8us, 0xFFE8us, 0xFFE8us, 0xFFE8us, 0xFFE8us, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFECus, 0xFFFCus, 0xFFFCus, 0xFFFCus, 0xFFFCus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFFus, 0xFFFFus, 
	0xFE80us, 0xFE80us, 0xFF80us, 0xFF80us, 0xFFC0us, 0xFFC0us, 0xFFC0us, 0xFFC0us, 0xFFC0us, 0xFFC0us, 0xFFE0us, 0xFFE0us, 0xFFE8us, 0xFFE8us, 0xFFE8us, 0xFFF8us, 0xFFF8us, 0xFFFCus, 0xFFFCus, 0xFFFCus, 0xFFFCus, 0xFFFCus, 0xFFFCus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFEus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
	0xFF00us, 0xFF00us, 0xFF00us, 0xFF80us, 0xFF80us, 0xFF80us, 0xFFC0us, 0xFFC0us, 0xFFC0us, 0xFFE0us, 0xFFE0us, 0xFFE0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF0us, 0xFFF8us, 0xFFF8us, 0xFFF8us, 0xFFFCus, 0xFFFCus, 0xFFFCus, 0xFFFEus, 0xFFFEus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 0xFFFFus, 
};

vec3 acesFilm(vec3 x) {
	float a = 2.51;
	float b = 0.03;
	float c = 2.43;
	float d = 0.59;
	float e = 0.14;
	return clamp((x*(a*x+b))/(x*(c*x+d)+e), vec3(0.0), vec3(1.0));
}

vec3 tonemapFrag(vec3 fragHDR, float exposure) {
	fragHDR *= exposure;
	vec3 mappedFrag = pow(fragHDR, vec3(1.0/2.2)); // Simple gamma correction
	return mappedFrag;
}

void transformEdgeInfoOrigin(vec2 neighborOffset, inout uint angleIndex, inout uint distIndex) {
	float angle = (float(angleIndex) / 31.0) * 2.0 * 3.141592;
	float dist = float(distIndex) / 31.0 * 0.55;
	
	vec2 normal = vec2(sin(angle), -cos(angle));
	vec2 scaledNormal = normal * dist;
	
	vec2 tangent = vec2(-normal.y, normal.x);
	
	vec2 edgeEnd1 = 0.5 + scaledNormal + tangent;
	vec2 edgeEnd2 = 0.5 + scaledNormal - tangent;
	
	vec2 neighborCenter = 0.5 + neighborOffset;
	
	float newDist = abs(dot(vec4(edgeEnd2.yx - edgeEnd1.yx, edgeEnd2.xy), vec4(neighborCenter.x, -neighborCenter.y, edgeEnd1.y, -edgeEnd1.x))) / distance(edgeEnd1.xy, edgeEnd2.xy);
	
	uint newAngleIndex = uint(round(mod(48.0 - float(angleIndex), 32.0)));
	uint newDistIndex = uint(round(clamp(newDist / 0.55, 0.0, 1.0) * 31.0));
	angleIndex = newAngleIndex;
	distIndex = newDistIndex;
}

void main() {
	// Sample scene frag
	vec3 sceneFragHDR = texture(texSceneHDR, vScreenTexCoord.st).rgb;
	
	// DEBUG:
	ivec2 iscreenUV = ivec2(vScreenTexCoord.st * vec2(1600.0, 900.0));
	
	float depthVariance = 0.0;
	float depthMean = 0.0;
	const int NUM_SAMPLES = 5;
	for(int i = 0; i < NUM_SAMPLES; i++) {
		float depth = texelFetch(texSceneDepthMS, iscreenUV.st, i).r;
		depthMean += depth / float(NUM_SAMPLES);
	}
	for(int i = 0; i < NUM_SAMPLES; i++) {
		float elem = texelFetch(texSceneDepthMS, iscreenUV.st, i).r - depthMean;
		depthVariance += (elem*elem) / float(NUM_SAMPLES);
	}
	
//	sceneFragHDR = vec3(depthMean * 64.0);
//	sceneFragHDR = vec3(depthVariance * 10000.0);
	
	// DEBUG:
	float centerDepth = texelFetch(texSceneDepthMS, iscreenUV.st, 0).r;
	
	/*
	const ivec2 pullNeighborOffsets[5] = {
		ivec2(0, 0),
		
		ivec2(+1, 0),
		ivec2(-1, 0),
		ivec2(0, +1),
		ivec2(0, -1),
	};
	*/
	const ivec2 pullNeighborOffsets[8] = {
		ivec2(+1, 0),
		ivec2(-1, 0),
		ivec2(0, +1),
		ivec2(0, -1),
		
		ivec2(0, +1),
		ivec2(0, -1),
		ivec2(+1, 0),
		ivec2(-1, 0),
	};
	
	uint coverageMask = texture(texEHAAEdgeHeuristic, vScreenTexCoord.st).r;
	
	float pulledNum = 0.0;
	vec3 pulledAccum = vec3(0.0);
	
	float depthMeanQuantized = 1.0;
	for(int i = 1; i < NUM_SAMPLES; i++) {
		float otherDepth = texelFetch(texSceneDepthMS, iscreenUV.st, i).r;
		
		// It should work to just calc one EPS value based on the center/color sample depth
		// that is then used for comparison with all the other samples.
		// This means we only have to do one linearization operation (for the EPS)
		// instead of one for each sample!
		float EPS = 0.00001;
//		if(centerDepth + EPS < otherDepth || centerDepth - EPS > otherDepth) {
//		if((centerDepth == 0.0) ^^ (otherDepth == 0.0)) {
		if(((coverageMask >> (i - 1)) & 1) == 0) {
			const float fac = 1.0;
			pulledNum += fac;
//			pulledAccum += (1.0/5.0) * textureOffset(texSceneHDR, vScreenTexCoord.st, -pullNeighborOffsets[i]).rgb;
			pulledAccum += (fac/float(NUM_SAMPLES)) * tonemapFrag(textureOffset(texSceneHDR, vScreenTexCoord.st, pullNeighborOffsets[i]).rgb, 1.0);
			
			depthMeanQuantized -= (1.0/float(NUM_SAMPLES));
		}
	}
	
	// if(dot(sceneFragHDR, vec3(1.0)) != 0.0) {
	// 	sceneFragHDR = vec3(1.0);
	// }
	
//	sceneFragHDR = tonemapFrag(sceneFragHDR, 1.0) * (centerDepth == 0.0 ? vec3(1.0 - depthMeanQuantized) : vec3(depthMeanQuantized));
	sceneFragHDR = (1.0 - min(1.0, pulledNum/float(NUM_SAMPLES)))*tonemapFrag(sceneFragHDR, 1.0) + pulledAccum;
//	sceneFragHDR = tonemapFrag(sceneFragHDR, 1.0);
//	sceneFragHDR = (1.0 - min(1.0, pulledNum/float(NUM_SAMPLES)))*tonemapFrag(sceneFragHDR, 1.0) + pulledAccum;
//	sceneFragHDR = (1.0 - pulledNum/5.0)*sceneFragHDR + pulledAccum;
//	sceneFragHDR = sceneFragHDR*depthMeanQuantized;
//	sceneFragHDR = sceneFragHDR * depthMean * 512.0;
//	sceneFragHDR = pulledAccum;
//	sceneFragHDR = sceneFragHDR*128.0*depthMean;
//	sceneFragHDR = vec3(step(0.1, dot(sceneFragHDR, vec3(1.0))) * depthMeanQuantized);
//	sceneFragHDR = vec3(depthMeanQuantized);
	
	/*
	if(centerDepth == 0.0) {
		sceneFragHDR.b += 0.5;
	}
	*/
	
	{// New algorithm
		// PROBLEM #1: We can still sample our own triangle by accident on slight angles
		// PROBLEM #2: How to blend pulled samples together? (Possibly related to the problem #1)
		
		/*
		const vec2 invTexSize = 1.0 / vec2(textureSize(texSceneHDR, 0));
		vec4 edgeCoeffs = texture(texEHAAEdgeHeuristic, vScreenTexCoord.st).xyzw;
		
		vec4 adjacentCoverageFactors = normalize(edgeCoeffs.xyzw);
		
		// DEBUG:
		vec3 pulledFrag = texture(texSceneHDR, vScreenTexCoord + vec2(invTexSize.x, 0.0)).rgb;
		//sceneFragHDR = mix(sceneFragHDR, pulledFrag, edgeCoeffs[0]*0.5);
		//sceneFragHDR = vec3(edgeCoeffs[0], 0.0, 0.0);
		*/
		
		/*
		// DEBUG:
		vec3 ownEdgeAngleIndicesFloat = texture(texEHAAEdgeHeuristic, vScreenTexCoord.st).xyz;
		vec3 ownEdgeDistIndicesFloat = texture(texEHAAEdgeHeuristic2, vScreenTexCoord.st).xyz;
		
		uvec3 ownEdgeAngleIndices = uvec3(round(ownEdgeAngleIndicesFloat * 31.0));
		uvec3 ownEdgeDistIndices = uvec3(round(ownEdgeDistIndicesFloat * 31.0));
		
		uint16_t ownCoverageMask;
		ownCoverageMask = EDGE_TO_COVERGE_MARK_LUT[ownEdgeAngleIndices[0] * 32u + ownEdgeDistIndices[0]]
			& EDGE_TO_COVERGE_MARK_LUT[ownEdgeAngleIndices[1] * 32u + ownEdgeDistIndices[1]]
			& EDGE_TO_COVERGE_MARK_LUT[ownEdgeAngleIndices[2] * 32u + ownEdgeDistIndices[2]];
		
		if(ownEdgeAngleIndicesFloat.x == 0.0 && ownEdgeDistIndicesFloat.x == 0.0) {
			ownCoverageMask = 0us;
		}
		
		float ownCoverageFactor = float(bitCount(ownCoverageMask)) / 16.0;
		//sceneFragHDR = vec3(ownCoverageFactor);
		
		{
			vec3 neighborEdgeAngles = textureOffset(texEHAAEdgeHeuristic, vScreenTexCoord.st, ivec2(1, 0)).xyz;
			vec3 neighborEdgeDists = textureOffset(texEHAAEdgeHeuristic2, vScreenTexCoord.st, ivec2(1, 0)).xyz;
			
			uvec3 neighborEdgeAngleIndices = uvec3(round(neighborEdgeAngles * 31.0));
			uvec3 neighborEdgeDistIndices = uvec3(round(neighborEdgeDists * 31.0));
			
			// Transform origin from neighbor's to our's
			transformEdgeInfoOrigin(vec2(1.0, 0.0), neighborEdgeAngleIndices[0], neighborEdgeDistIndices[0]);
			transformEdgeInfoOrigin(vec2(1.0, 0.0), neighborEdgeAngleIndices[1], neighborEdgeDistIndices[1]);
			transformEdgeInfoOrigin(vec2(1.0, 0.0), neighborEdgeAngleIndices[2], neighborEdgeDistIndices[2]);
			
			uint16_t neighborOnUsCoverageMask;
			neighborOnUsCoverageMask = ~EDGE_TO_COVERGE_MARK_LUT[neighborEdgeAngleIndices[0] * 32u + neighborEdgeDistIndices[0]]
				& ~EDGE_TO_COVERGE_MARK_LUT[neighborEdgeAngleIndices[1] * 32u + neighborEdgeDistIndices[1]]
				& ~EDGE_TO_COVERGE_MARK_LUT[neighborEdgeAngleIndices[2] * 32u + neighborEdgeDistIndices[2]];
			
			uint16_t pullCoverageMask = (neighborOnUsCoverageMask & ~ownCoverageMask) | (~ownCoverageMask & 0x8CC8us);
			float pullFactor = float(bitCount(pullCoverageMask)) / 16.0;
			
			vec3 neighborFrag = textureOffset(texSceneHDR, vScreenTexCoord.st, ivec2(1, 0)).rgb;
			//sceneFragHDR = mix(sceneFragHDR, neighborFrag, pullFactor);
		}
		*/
		
		/*
		float maxCoeff = max(max(edgeCoeffs[0], edgeCoeffs[1]), max(edgeCoeffs[2], edgeCoeffs[3]));
		if(maxCoeff > 0.0001) {
			vec3 pulledFrag = vec3(0.0);
			pulledFrag += tonemapFrag(texture(texSceneHDR, vScreenTexCoord + vec2(invTexSize.x, 0.0)).rgb, 1.0) * adjacentCoverageFactors[0];
			pulledFrag += tonemapFrag(texture(texSceneHDR, vScreenTexCoord + vec2(0.0, invTexSize.y)).rgb, 1.0) * adjacentCoverageFactors[1];
			pulledFrag += tonemapFrag(texture(texSceneHDR, vScreenTexCoord - vec2(invTexSize.x, 0.0)).rgb, 1.0) * adjacentCoverageFactors[2];
			pulledFrag += tonemapFrag(texture(texSceneHDR, vScreenTexCoord - vec2(0.0, invTexSize.y)).rgb, 1.0) * adjacentCoverageFactors[3];
			pulledFrag *= 1.0 / dot(adjacentCoverageFactors, vec4(1.0));
			
			sceneFragHDR = mix(tonemapFrag(sceneFragHDR, 1.0), pulledFrag, maxCoeff);
		}
		*/
	}
	
	/*
	{// DEBUG:
		vec2 invTexSize = 1.0 / vec2(textureSize(texSceneHDR, 0));
		
		vec4 ehaaFrag = texture(texEHAAEdgeHeuristic, vScreenTexCoord.st).xyzw;
		vec2 normal = normalize(ehaaFrag.yz * 2.0 - 1.0);
		
		vec2 sampleNormal = sign(normal) * step(vec2(0.5), abs(normal));
		
		vec2 sampleOffset = invTexSize * sampleNormal;
		vec3 pulledFrag = texture(texSceneHDR, vScreenTexCoord + sampleOffset).rgb;
		
		sceneFragHDR = mix(tonemapFrag(sceneFragHDR), tonemapFrag(pulledFrag), ehaaFrag.x);
		//sceneFragHDR = vec3(sampleNormal * 0.5 + 0.5, 0.0);
	}
	*/
	
	// Tone map and gamma correct fragment
	float exposure = 1.0;
//	vec3 tonemappedFrag = tonemapFrag(sceneFragHDR, exposure);
	vec3 tonemappedFrag = sceneFragHDR;
	
	// Write final processed frag
	outFragProcessed = tonemappedFrag;
}
